package fuse

import (
	"context"
	"fmt"
	"io"
	"log"
	"os"
	"syscall"
	"time"

	"bazil.org/fuse"
	"bazil.org/fuse/fs"
	"github.com/nestybox/sysvisor/sysvisor-fs/domain"
)

type File struct {
	// File name.
	name string

	// File absolute-path + name.
	path string

	// File attributes.
	attr *fuse.Attr

	// I/O abstraction to represent each file/dir.
	ionode domain.IOnode

	// Pointer to parent fuseService hosting this file/dir.
	service *fuseService
}

//
// NewFile method serves as File constructor.
//
func NewFile(name string, path string, attr *fuse.Attr, srv *fuseService) *File {

	newFile := &File{
		name:    name,
		path:    path,
		attr:    attr,
		service: srv,
		ionode:  srv.ios.NewIOnode(name, path, attr.Mode),
	}

	return newFile
}

//
// Attr FS operation.
//
func (f *File) Attr(ctx context.Context, a *fuse.Attr) error {

	log.Println("Requested Attr() operation for entry", f.path)

	// Simply return the attributes that were previously collected during the
	// lookup() execution.
	*a = *f.attr

	return nil
}

//
// Getattr FS operation.
//
func (f *File) Getattr(
	ctx context.Context,
	req *fuse.GetattrRequest,
	resp *fuse.GetattrResponse) error {

	log.Println("Requested GetAttr() operation for entry", f.path)

	// Lookup the associated handler within handler-DB.
	handler, ok := f.service.hds.LookupHandler(f.ionode)
	if !ok {
		log.Printf("No supported handler for %v resource", f.path)
		return fmt.Errorf("No supported handler for %v resource", f.path)
	}

	// Handler execution.
	stat, err := handler.Getattr(f.ionode, req.Pid)
	if err != nil {
		log.Println("Error while running Getattr(): ", err)
		return err
	}

	// Simply return the attributes that were previously collected during the
	// lookup() execution, with the exception of the UID/GID, which must be
	// updated based on the obtained response.
	resp.Attr = *f.attr
	resp.Attr.Uid = stat.Uid
	resp.Attr.Gid = stat.Gid

	return nil
}

//
// Open FS operation.
//
func (f *File) Open(
	ctx context.Context,
	req *fuse.OpenRequest,
	resp *fuse.OpenResponse) (fs.Handle, error) {

	log.Println("Requested Open() operation for entry", f.path)

	f.ionode.SetOpenFlags(int(req.Flags))

	// Lookup the associated handler within handler-DB.
	handler, ok := f.service.hds.LookupHandler(f.ionode)
	if !ok {
		log.Printf("No supported handler for %v resource", f.path)
		return nil, fmt.Errorf("No supported handler for %v resource", f.path)
	}

	// Handler execution.
	err := handler.Open(f.ionode)
	//
	// TODO: If no open-rights are granted, the error-msg being returned
	// back to the user must match the one reported for non-emulated
	// resources. At this moment, we are observing slightly different
	// error messages:
	//
	// * Within a syscontainer:
	//
	// root@691a4b387c60:/# cat > /proc/uptime
	// bash: /proc/uptime: Input/output error
	//
	// * Within the regular host FS:
	//
	// $ sudo cat > /proc/uptime
	// bash: /proc/uptime: Permission denied
	//
	if err != nil && err != io.EOF {
		return nil, err
	}

	// procfs and sysfs hold non-seekable files.
	resp.Flags |= fuse.OpenNonSeekable

	//
	// Due to the nature of procfs and sysfs, files lack explicit sizes (other
	// than zero) as regular files have. In consequence, read operations (also
	// writes) may not be properly handled by kernel, as these ones extend
	// beyond the file sizes reported by Attr() / GetAttr().
	//
	// A solution to this problem is to rely on O_DIRECT flag for all the
	// interactions with procfs/sysfs files. By making use of this flag,
	// sysvisor-fs will ensure that it receives all read/write requests
	// generated by fuse-clients, regardless of the file-size issue mentioned
	// above. For regular files, this approach usually comes with a cost, as
	// page-cache is being bypassed for all files I/O; however, this doesn't
	// pose a problem for Inception as we are dealing with special FSs.
	//
	resp.Flags |= fuse.OpenDirectIO

	return f, nil
}

//
// Release FS operation.
//
func (f *File) Release(ctx context.Context, req *fuse.ReleaseRequest) error {

	log.Println("Requested Release() operation for entry", f.path)

	// Lookup the associated handler within handler-DB.
	handler, ok := f.service.hds.LookupHandler(f.ionode)
	if !ok {
		log.Printf("No supported handler for %v resource", f.path)
		return fmt.Errorf("No supported handler for %v resource", f.path)
	}

	// Handler execution.
	err := handler.Close(f.ionode)

	return err
}

//
// Read FS operation.
//
func (f *File) Read(
	ctx context.Context,
	req *fuse.ReadRequest,
	resp *fuse.ReadResponse) error {

	log.Println("Requested Read() operation for entry", f.path)

	if f.ionode == nil {
		log.Println("Read: File should be open by now -- aborting request")
		return fuse.ENOTSUP
	}

	// Adjust receiving buffer to the request's size.
	resp.Data = resp.Data[:req.Size]

	// Identify the associated handler and execute it accordingly.
	handler, ok := f.service.hds.LookupHandler(f.ionode)
	if !ok {
		log.Printf("No supported handler for %v resource", f.path)
		return fmt.Errorf("No supported handler for %v resource", f.path)
	}

	// Handler execution.
	n, err := handler.Read(f.ionode, req.Pid, resp.Data, req.Offset)
	if err != nil && err != io.EOF {
		log.Println("Read ERR: ", err)
		return err
	}

	resp.Data = resp.Data[:n]

	return nil
}

//
// Write FS operation.
//
func (f *File) Write(
	ctx context.Context,
	req *fuse.WriteRequest,
	resp *fuse.WriteResponse) error {

	log.Println("Requested Write() operation for entry", f.path)

	if f.ionode == nil {
		log.Println("Write: File should be opened by now -- aborting request")
		return fuse.ENOTSUP
	}

	// Lookup the associated handler within handler-DB.
	handler, ok := f.service.hds.LookupHandler(f.ionode)
	if !ok {
		log.Printf("No supported handler for %v resource", f.path)
		return fmt.Errorf("No supported handler for %v resource", f.path)
	}

	// Handler execution.
	n, err := handler.Write(f.ionode, req.Pid, req.Data)
	if err != nil && err != io.EOF {
		log.Println("Write ERR: ", err)
		return err
	}

	resp.Size = n

	return nil
}

//
// Size method returns the 'size' of a File element.
//
func (f *File) Size() uint64 {
	return f.attr.Size
}

//
// Mode method returns the 'mode' of a File element.
//
func (f *File) Mode() os.FileMode {
	return f.attr.Mode
}

//
// ModTime method returns the modification-time of a File element.
//
func (f *File) ModTime() time.Time {
	return f.attr.Mtime
}

//
// statToAttr helper function to translate FS node-parameters from unix/kernel
// format to FUSE ones.
//
// Kernel FS node attribs:  fuse.attr (fuse_kernel*.go)
// FUSE node attribs:       fuse.Attr (fuse.go)
//
// TODO: Place me in a more appropiate location
//
func statToAttr(s *syscall.Stat_t) fuse.Attr {

	var a fuse.Attr

	a.Inode = uint64(s.Ino)
	a.Size = uint64(s.Size)
	a.Blocks = uint64(s.Blocks)

	a.Atime = time.Unix(s.Atim.Sec, s.Atim.Nsec)
	a.Mtime = time.Unix(s.Mtim.Sec, s.Mtim.Nsec)
	a.Ctime = time.Unix(s.Ctim.Sec, s.Ctim.Nsec)

	a.Mode = os.FileMode(s.Mode)
	a.Nlink = uint32(s.Nlink)
	a.Uid = uint32(s.Uid)
	a.Gid = uint32(s.Gid)
	a.Rdev = uint32(s.Rdev)
	a.BlockSize = uint32(s.Blksize)

	return a
}
