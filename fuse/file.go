package fuse

import (
	"context"
	"errors"
	"io"
	"log"
	"os"
	"strconv"
	"syscall"
	"time"

	"bazil.org/fuse"
	"bazil.org/fuse/fs"
	"github.com/nestybox/sysvisor/sysvisor-fs/domain"

	"github.com/spf13/afero"
)

// TODO: Provide a better description.
var appFS = afero.NewOsFs()

// Global variable to keep track of inode values assigned to virtual fsNodes.
var inode uint64

func newInode() uint64 {
	inode++
	return inode
}

// Ensure fuseFile implements file.Service
//var _ ionode.Interface = fuseFile{}

type File struct {
	// File absolute-path + name.
	path string

	//
	attr *fuse.Attr

	//
	ionode domain.IOnode

	//
	service *fuseService
}

//
// NewFile method serves as File constructor.
//
func NewFile(path string, attr *fuse.Attr, srv *fuseService) *File {

	newFile := &File{
		path:    path,
		attr:    attr,
		service: srv,
		ionode:  srv.ios.NewIOnode(path, attr.Mode),
	}

	return newFile
}

//
// Attr FS operation.
//
func (f *File) Attr(ctx context.Context, a *fuse.Attr) error {

	log.Println("Requested Attr() operation for entry", f.path)

	*a = *f.attr

	return nil
}

//
// Getattr FS operation.
//
func (f *File) Getattr(
	ctx context.Context,
	req *fuse.GetattrRequest,
	resp *fuse.GetattrResponse) error {

	log.Println("Requested GetAttr() operation for entry", f.path)

	resp.Attr = *f.attr

	resp.Attr.Uid = req.Uid
	resp.Attr.Gid = req.Gid

	return nil
}

//
// Open FS operation.
//
func (f *File) Open(
	ctx context.Context,
	req *fuse.OpenRequest,
	resp *fuse.OpenResponse) (fs.Handle, error) {

	log.Println("Requested Open() operation for entry", f.path)

	f.ionode.SetOpenFlags(int(req.Flags))
	// If dealing with an emulated resource, execute the associated handle.
	if handler, ok := f.service.hds.LookupHandler(f.path); ok {

		// Handler execution.
		err := handler.Open(f.ionode)
		//
		// TODO: If no open-rights are granted, the error-msg being returned
		// back to the user must match the one reported for non-emulated
		// resources. At this moment, we are observing slightly different
		// error messages:
		//
		// * Within a syscontainer:
		//
		// root@691a4b387c60:/# cat > /proc/uptime
		// bash: /proc/uptime: Input/output error
		//
		// * Within the regular host FS:
		//
		// $ sudo cat > /proc/uptime
		// bash: /proc/uptime: Permission denied
		//
		if err != nil && err != io.EOF {
			return nil, err
		}
	} else {

		if err := f.service.ios.OpenNode(f.ionode); err != nil {
			log.Print("Open ERR")
			return nil, errors.New("Error opening file")
		}
	}

	// procfs and sysfs hold non-seekable files.
	resp.Flags |= fuse.OpenNonSeekable

	//
	// Due to the nature of procfs and sysfs, files lack explicit sizes (other
	// than zero) as regular files have. In consequence, read operations (also
	// writes) may not be properly handled by kernel, as these ones extend
	// beyond the file sizes reported by Attr() / GetAttr().
	//
	// A solution to this problem is to rely on O_DIRECT flag for all the
	// interactions with procfs/sysfs files. By making use of this flag,
	// sysvisor-fs will ensure that it receives all read/write requests
	// generated by fuse-clients, regardless of the file-size issue mentioned
	// above. For regular files, this approach usually comes with a cost, as
	// page-cache is being bypassed for all files I/O; however, this doesn't
	// pose a problem for Inception as we are dealing with special FSs.
	//
	resp.Flags |= fuse.OpenDirectIO

	return f, nil
}

//
// Release FS operation.
//
func (f *File) Release(ctx context.Context, req *fuse.ReleaseRequest) error {

	log.Println("Requested Release() operation for entry", f.path)

	return f.service.ios.CloseNode(f.ionode)
}

//
// Read FS operation.
//
func (f *File) Read(
	ctx context.Context,
	req *fuse.ReadRequest,
	resp *fuse.ReadResponse) error {

	log.Println("Requested Read on file", f.path)

	if f.ionode == nil {
		log.Println("Read: File should be open by now -- aborting request")
		return fuse.ENOTSUP
	}

	// Adjust receiving buffer to the request's size.
	resp.Data = resp.Data[:req.Size]

	var (
		n   int
		err error
	)

	// If dealing with an emulated resource, execute the associated handle.
	if handler, ok := f.service.hds.LookupHandler(f.path); ok {

		// Identify the pidNsInode corresponding to this pid.
		tmpNode := f.service.ios.NewIOnode(strconv.Itoa(int(req.Pid)), 0)
		pidInode, err := f.service.ios.PidNsInode(tmpNode)
		if err != nil {
			return err
		}

		// Handler execution.
		n, err = handler.Read(f.ionode, pidInode, resp.Data, req.Offset)
		if err != nil && err != io.EOF {
			return err
		}

	} else {
		n, err = f.service.ios.ReadAtNode(f.ionode, resp.Data, req.Offset)
		if err != nil && err != io.EOF {
			log.Println("Read ERR: ", err)
			return err
		}
	}

	resp.Data = resp.Data[:n]

	return nil
}

//
// Write FS operation.
//
func (f *File) Write(
	ctx context.Context,
	req *fuse.WriteRequest,
	resp *fuse.WriteResponse) error {

	log.Println("Requested Write on file", f.path)

	if f.ionode == nil {
		log.Println("Write: File should be opened by now -- aborting request")
		return fuse.ENOTSUP
	}

	var (
		n   int
		err error
	)

	// If dealing with an emulated resource, execute the associated handle.
	if handler, ok := f.service.hds.LookupHandler(f.path); ok {

		// Identify the pidNsInode corresponding to this pid.
		tmpNode := f.service.ios.NewIOnode(strconv.Itoa(int(req.Pid)), 0)
		pidInode, err := f.service.ios.PidNsInode(tmpNode)
		if err != nil {
			return err
		}

		// Handler execution.
		n, err = handler.Write(f.ionode, pidInode, req.Data)
		if err != nil && err != io.EOF {
			return err
		}

	} else {
		n, err = f.service.ios.WriteNode(f.ionode, req.Data)
		if err != nil {
			log.Println("Write ERR: ", err)
			return err
		}
	}

	resp.Size = n

	return nil
}

//
// Size method returns the 'size' of a File element.
//
func (f *File) Size() uint64 {
	return f.attr.Size
}

//
// Mode method returns the 'mode' of a File element.
//
func (f *File) Mode() os.FileMode {
	return f.attr.Mode
}

//
// ModTime method returns the modification-time of a File element.
//
func (f *File) ModTime() time.Time {
	return f.attr.Mtime
}

//
// StatToAttr helper function to translate FS node-parameters from unix/kernel
// format to FUSE ones.
//
// Kernel FS node attribs:  fuse.attr (fuse_kernel*.go)
// FUSE node attribs:       fuse.Attr (fuse.go)
//
// TODO: Place me in a more appropiate location
//
func StatToAttr(s *syscall.Stat_t) fuse.Attr {

	var a fuse.Attr

	a.Inode = uint64(s.Ino)
	a.Size = uint64(s.Size)
	a.Blocks = uint64(s.Blocks)

	a.Atime = time.Unix(s.Atim.Sec, s.Atim.Nsec)
	a.Mtime = time.Unix(s.Mtim.Sec, s.Mtim.Nsec)
	a.Ctime = time.Unix(s.Ctim.Sec, s.Ctim.Nsec)

	a.Mode = os.FileMode(s.Mode)
	a.Nlink = uint32(s.Nlink)
	a.Uid = uint32(s.Uid)
	a.Gid = uint32(s.Gid)
	a.Rdev = uint32(s.Rdev)
	a.BlockSize = uint32(s.Blksize)

	return a
}

/*

// Global variable to keep track of inode values assigned to virtual fsNodes.
var inode uint64

func newInode() uint64 {
	inode++
	return inode
}

//
// File struct to serve as a FUSE-friendly abstraction to represent files from
// the host FS. The 'file' term in this context carries the semantics of UNIX
// based FS, where a 'file' entry represents different FS objects (i.e files,
// directories, soft-links, etc, etc).
//
type File struct {

	// File name.
	path string

	// FS attributes.
	attr *fuse.Attr

	// ioNode object to handle all I/O related logic.
	ionode ioNode
}

//
// NewFile method serves as File constructor.
//
func NewFile(path string, attr *fuse.Attr) *File {

	newFile := &File{
		path:   path,
		attr:   attr,
		ionode: nil,
	}

	newFile.attr.Inode = newInode()

	return newFile
}

//
// Attr FS operation.
//
func (f *File) Attr(ctx context.Context, a *fuse.Attr) error {

	log.Println("Requested Attr() operation for entry", f.path)

	*a = *f.attr

	return nil
}

//
// Getattr FS operation.
//
func (f *File) Getattr(
	ctx context.Context,
	req *fuse.GetattrRequest,
	resp *fuse.GetattrResponse) error {

	log.Println("Requested GetAttr() operation for entry", f.path)

	resp.Attr = *f.attr

	resp.Attr.Uid = req.Uid
	resp.Attr.Gid = req.Gid

	return nil
}

//
// Open FS operation.
//
func (f *File) Open(
	ctx context.Context,
	req *fuse.OpenRequest,
	resp *fuse.OpenResponse) (fs.Handle, error) {

	log.Println("Requested Open() operation for entry", f.path)

	// Check if we are dealing with a sysvisor-fs' emulated resource.
	if handler, ok := (domain.handlerMap)[f.path]; ok {
		//
		// Find the container-state corresponding to the container hosting this
		// Pid.
		//
		cs, err := findContainerByPid(req.Pid)
		if err != nil {
			log.Printf("Could not find the container originating this request (PID %d)\n", req.Pid)
			return nil, err
		}

		// Handler execution. Notice that here we are just verifying open()
		// rights for emulated resources, the actual opening action will take
		// place further below.
		err = handler.open(cs, &req.Flags)

		//
		// TODO: If no open-rights are granted, the error-msg being returned
		// back to the user must match the one reported for non-emulated
		// resources. At this moment, we are observing slightly different
		// error messages:
		//
		// * Within a syscontainer:
		//
		// root@691a4b387c60:/# cat > /proc/uptime
		// bash: /proc/uptime: Input/output error
		//
		// * Within the regular host FS:
		//
		// $ sudo cat > /proc/uptime
		// bash: /proc/uptime: Permission denied
		//
		if err != nil && err != io.EOF {
			return nil, err
		}
	}

	f.ionode = newIoNode(f.path, int(req.Flags), f.attr.Mode)
	if f.ionode == nil {
		log.Print("Open ERR")
		return nil, errors.New("Error opening file")
	}

	// procfs and sysfs hold non-seekable files.
	resp.Flags |= fuse.OpenNonSeekable

	//
	// Due to the nature of procfs and sysfs, files lack explicit sizes (other
	// than zero) as regular files have. In consequence, read operations (also
	// writes) may not be properly handled by kernel, as these ones extend
	// beyond the file sizes reported by Attr() / GetAttr().
	//
	// A solution to this problem is to rely on O_DIRECT flag for all the
	// interactions with procfs/sysfs files. By making use of this flag,
	// sysvisor-fs will ensure that it receives all read/write requests
	// generated by fuse-clients, regardless of the file-size issue mentioned
	// above. For regular files, this approach usually comes with a cost, as
	// page-cache is being bypassed for all files I/O; however, this doesn't
	// pose a problem for Inception as we are dealing with special FSs.
	//
	resp.Flags |= fuse.OpenDirectIO

	return f, nil
}

//
// Release FS operation.
//
func (f *File) Release(ctx context.Context, req *fuse.ReleaseRequest) error {

	log.Println("Requested Release() operation for entry", f.path)

	return f.ionode.Close()
}

//
// Read FS operation.
//
func (f *File) Read(
	ctx context.Context,
	req *fuse.ReadRequest,
	resp *fuse.ReadResponse) error {

	log.Println("Requested Read on file", f.path)

	if f.ionode == nil {
		log.Println("Read: File should be open by now -- aborting request")
		return fuse.ENOTSUP
	}

	// Adjust receiving buffer to the request's size.
	resp.Data = resp.Data[:req.Size]

	var (
		n   int
		err error
	)

	// Address special read() requests for virtualized resources.
	if handler, ok := (domain.handlerMap)[f.path]; ok {
		//
		// Find the container-state conrresponding to the container hosting this
		// Pid.
		//
		cs, err := findContainerByPid(req.Pid)
		if err != nil {
			log.Printf("Could not find the container originating this request (PID %d)\n", req.Pid)
			return err
		}

		n, err = handler.read(f.ionode, cs, resp.Data, req.Offset)
		if err != nil && err != io.EOF {
			return err
		}
	} else {
		n, err = f.ionode.ReadAt(resp.Data, req.Offset)
		if err != nil && err != io.EOF {
			log.Println("Read ERR: ", err)
			return err
		}
	}

	resp.Data = resp.Data[:n]

	return nil
}

//
// Write FS operation.
//
func (f *File) Write(
	ctx context.Context,
	req *fuse.WriteRequest,
	resp *fuse.WriteResponse) error {

	log.Println("Requested Write on file", f.path)

	if f.ionode == nil {
		log.Println("Write: File should be opened by now -- aborting request")
		return fuse.ENOTSUP
	}

	var (
		n   int
		err error
	)

	// Address special write() requests for virtualized resources.
	if handler, ok := (domain.handlerMap)[f.path]; ok {
		//
		// Find the container-state corresponding to the container hosting this
		// Pid.
		//
		cs, err := findContainerByPid(req.Pid)
		if err != nil {
			log.Printf("Could not find the container originating this request (PID %d)\n", req.Pid)
			return err
		}

		n, err = handler.write(f.ionode, cs, req.Data)
		if err != nil && err != io.EOF {
			return err
		}
	} else {
		n, err = f.ionode.Write(req.Data)
		if err != nil {
			log.Println("Write ERR: ", err)
			return err
		}
	}

	resp.Size = n

	return nil
}

//
// Size method returns the 'size' of a File element.
//
func (f *File) Size() uint64 {
	return f.attr.Size
}

//
// Mode method returns the 'mode' of a File element.
//
func (f *File) Mode() os.FileMode {
	return f.attr.Mode
}

//
// ModTime method returns the modification-time of a File element.
//
func (f *File) ModTime() time.Time {
	return f.attr.Mtime
}


*/
