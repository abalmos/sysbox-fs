package main

import (
	"context"
	"io"
	"log"
	"os"
	"time"

	"bazil.org/fuse"
	"bazil.org/fuse/fs"
)

// Global variable to keep track of inode values assigned to virtual fsNodes.
var inode uint64

func newInode() uint64 {
	inode++
	return inode
}

//
// File struct to serve as a FUSE-friendly abstraction to represent files from
// the host FS. The 'file' term in this context carries the semantics of UNIX
// based FS, where a 'file' entry represents different FS objects (i.e files,
// directories, soft-links, etc, etc).
//
type File struct {

	// File name
	path string

	// FS attributes
	attr *fuse.Attr

	// Handle utilized by FUSE FS to refer to files/dirs currently opened.
	handle *os.File
}

//
// NewFile method serves as File constructor.
//
func NewFile(path string, attr *fuse.Attr) *File {

	newFile := &File{
		path:   path,
		attr:   attr,
		handle: nil,
	}

	newFile.attr.Inode = newInode()

	return newFile
}

//
// Attr FS operation.
//
func (f *File) Attr(ctx context.Context, a *fuse.Attr) error {

	log.Println("Requested Attr() operation for entry", f.path)

	*a = *f.attr

	return nil
}

//
// Getattr FS operation.
//
func (f *File) Getattr(
	ctx context.Context,
	req *fuse.GetattrRequest,
	resp *fuse.GetattrResponse) error {

	log.Println("Requested GetAttr() operation for entry", f.path)

	resp.Attr = *f.attr

	resp.Attr.Uid = req.Uid
	resp.Attr.Gid = req.Gid

	return nil
}

//
// Open FS operation.
//
func (f *File) Open(
	ctx context.Context,
	req *fuse.OpenRequest,
	resp *fuse.OpenResponse) (fs.Handle, error) {

	log.Println("Requested Open() operation for entry", f.path)

	// Find the container-state corresponding to the container hosting this Pid.
	cs, err := findContainerByPid(req.Pid)
	if err != nil {
		log.Printf("Could not find the container originating this request ",
			"(PID %d)\n", req.Pid)
		return nil, err
	}

	// Verify open() rights for sysvisorfs' emulated resources.
	if handler, ok := (sysfs.handlerMap)[f.path]; ok {
		err := handler.open(cs, req.Flags)
		//
		// TODO: If no open-rights are granted, the error-msg being returned
		// back to the user must match the one reported for non-emulated
		// resources. At this moment, we are observing slightly different
		// error messages:
		//
		// * Within a syscontainer:
		//
		// root@691a4b387c60:/# cat > /proc/uptime
		// bash: /proc/uptime: Input/output error
		//
		// * Within the regular host FS:
		//
		// $ sudo cat > /proc/uptime
		// bash: /proc/uptime: Permission denied
		//
		if err != nil && err != io.EOF {
			return nil, err
		}
	}

	handle, err := os.OpenFile(f.path, int(req.Flags), f.attr.Mode)
	if err != nil {
		log.Print("Open ERR: ", err)
		return nil, err
	}

	// procfs and sysfs hold non-seekable files.
	resp.Flags |= fuse.OpenNonSeekable

	//
	// Due to the nature of procfs and sysfs, files lack explicit sizes (other
	// than zero) as regular files have. In consequence, read operations (also
	// writes) may not be properly handled by kernel, as these ones extend
	// beyond the file sizes reported by Attr() / GetAttr().
	//
	// A solution to this problem is to rely on O_DIRECT flag for all the
	// interactions with procfs/sysfs files. By making use of this flag,
	// sysvisor-fs will ensure that it receives all read/write requests
	// generated by fuse-clients, regardless of the file-size issue mentioned
	// above. For regular files, this approach usually comes with a cost, as
	// page-cache is being bypassed for all files I/O; however, this doesn't
	// pose a problem for Inception as we are dealing with special FSs.
	//
	resp.Flags |= fuse.OpenDirectIO

	f.handle = handle

	return f, nil
}

//
// Release FS operation.
//
func (f *File) Release(ctx context.Context, req *fuse.ReleaseRequest) error {

	log.Println("Requested Release() operation for entry", f.path)

	return f.handle.Close()
}

//
// Read FS operation.
//
func (f *File) Read(
	ctx context.Context,
	req *fuse.ReadRequest,
	resp *fuse.ReadResponse) error {

	log.Println("Requested Read on file", f.path)

	if f.handle == nil {
		log.Println("Read: File should be open by now -- aborting request")
		return fuse.ENOTSUP
	}

	// Find the container-state conrresponding to the container hosting this Pid.
	cs, err := findContainerByPid(req.Pid)
	if err != nil {
		log.Printf("Could not find the container originating this request ",
			"(PID %d)\n", req.Pid)
		return err
	}

	// Adjust receiving buffer to the request's size.
	resp.Data = resp.Data[:req.Size]

	var n int

	// Address special read() requests for virtualized resources.
	if handler, ok := (sysfs.handlerMap)[f.path]; ok {

		n, err = handler.read(cs, resp.Data, req.Offset)
		if err != nil && err != io.EOF {
			return err
		}
	} else {
		// Regular I/O instruction to read from host FS.
		n, err = f.handle.ReadAt(resp.Data, req.Offset)
		if err != nil && err != io.EOF {
			log.Println("Read ERR: ", err)
			return err
		}
	}

	resp.Data = resp.Data[:n]

	return nil
}

//
// Write FS operation.
//
func (f *File) Write(
	ctx context.Context,
	req *fuse.WriteRequest,
	resp *fuse.WriteResponse) error {

	log.Println("Requested Write on file", f.path)

	if f.handle == nil {
		log.Println("Write: File should be opened by now -- aborting request")
		return fuse.ENOTSUP
	}

	// Find the container-state corresponding to the container hosting this Pid.
	cs, err := findContainerByPid(req.Pid)
	if err != nil {
		log.Printf("Could not find the container originating this request ",
			"(PID %d)\n", req.Pid)
		return err
	}

	var n int

	// Address special write() requests for virtualized resources.
	if handler, ok := (sysfs.handlerMap)[f.path]; ok {

		n, err = handler.write(cs, req.Data)
		if err != nil && err != io.EOF {
			return err
		}
	} else {
		// Regular I/O instruction to write to host FS.
		n, err = f.handle.Write(req.Data)
		if err != nil {
			log.Println("Write ERR: ", err)
			return err
		}
	}

	resp.Size = n

	return nil
}

//
// Size method returns the 'size' of a File element.
//
func (f *File) Size() uint64 {
	return f.attr.Size
}

//
// Mode method returns the 'mode' of a File element.
//
func (f *File) Mode() os.FileMode {
	return f.attr.Mode
}

//
// ModTime method returns the modification-time of a File element.
//
func (f *File) ModTime() time.Time {
	return f.attr.Mtime
}
